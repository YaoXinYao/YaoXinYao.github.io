<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>CSS面试笔记（更新中...）</title>
      <link href="/posts/7f3c58c4.html"/>
      <url>/posts/7f3c58c4.html</url>
      
        <content type="html"><![CDATA[<h3 id="CSS-选择器及其优先级">CSS 选择器及其优先级</h3><table><thead><tr><th>选择器</th><th>权重</th></tr></thead><tbody><tr><td>内联样式</td><td>1000</td></tr><tr><td>id 选择器</td><td>100</td></tr><tr><td>类选择器</td><td>10</td></tr><tr><td>属性选择器</td><td>10</td></tr><tr><td>伪类选择器</td><td>10</td></tr><tr><td>标签选择器</td><td>1</td></tr><tr><td>伪元素选择器</td><td>1</td></tr><tr><td>相邻兄弟元素元素</td><td>0</td></tr><tr><td>子选择器</td><td>0</td></tr><tr><td>后代选择器</td><td>0</td></tr><tr><td>通配符选择器</td><td>0</td></tr></tbody></table><p><strong>注：</strong></p><ul><li>!important 声明的样式的优先级最高</li><li>如果优先级相同，则最后出现的样式生效</li><li>继承得到的样式的优先级最低</li><li>通用选择器、子选择器、相邻兄弟选择器并不在这四个等级中，因为他们的权重为 0</li><li>样式表的来源不同时，优先级顺序在；内联样式&gt;内部样式&gt;外部样式&gt;浏览器用户自定义样式&gt;浏览器默认样式</li></ul><h3 id="CSS-中可继承与不可继承的属性有哪些？">CSS 中可继承与不可继承的属性有哪些？</h3><ol><li><h5 id="无继承性">无继承性</h5></li></ol><ul><li>display：规定元素应该生成的类型</li><li>文本属性：<ul><li>verical-align：垂直文本对齐</li><li>text-decoration：规定添加到文本的装饰</li><li>text-shadow：文本阴影效果</li><li>white-space：空白符的处理</li><li>unicode-bid：设置文本方向</li></ul></li><li>盒子模型属性：width、height、margin、border、padding</li><li>背景属性：background、background-color、background-image、background-repeat、background-position、background-attachment</li><li>定位属性：float、position、top、right、bottom、left、min-width、max-width、min-height、max-height、overflow、clip、z-index</li><li><strong>生成内容属性</strong>：content、counter-reset、counter-increment</li><li><strong>轮廓样式属性</strong>：outline-style、outline-width、outline-color、outline</li><li><strong>页面样式属性</strong>：size、page-break-before、page-break-after</li><li><strong>声音样式属性</strong>：pause-before、pause-after、pause、cue-before、cue-after、cue、play-during</li></ul><ol><li><h5 id="有继承性">有继承性</h5></li></ol><ul><li>字体系列属性<ul><li>font-family:字体系列</li><li>font-weight：字体粗细</li><li>font-size：字体大小</li><li>font-style:字体风格</li></ul></li><li>文本系列<ul><li>text-indent:文本缩进</li><li>text-align:文本水平对齐</li><li>line-height:行高</li><li>word-spacing:单词之间的间距</li><li>letter-spacing:中文或者字母之间的间距</li><li>text-transform:控制文本大小写</li><li>color:文本颜色</li></ul></li><li>元素可见性<ul><li>visibility:控制元素显示隐藏</li></ul></li><li>列表布局属性<ul><li>list-style:列表风格，包括 list-style-type、list-style-image 等</li></ul></li><li>光标属性<ul><li>cursor:光标显示为何种形态</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML面试笔记（更新中...）</title>
      <link href="/posts/7f3c58c3.html"/>
      <url>/posts/7f3c58c3.html</url>
      
        <content type="html"><![CDATA[<h3 id="HTML5-有哪些更新？">HTML5 有哪些更新？</h3><ul><li><p>语义化标签</p><ul><li>header:定义文档的页眉（头部）</li><li>nav:定义导航链接部分</li><li>footer:定义文档或节的页脚（底部）</li><li>article:定义文章内容</li><li>section:定义文档中节（section、区段）</li><li>aside:定义其所处内容之外的内容（侧边）</li></ul></li><li><p>媒体标签</p><ul><li><p>audio：音频</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">src</span>=<span class="string">&quot;&quot;</span> <span class="attr">controls</span> <span class="attr">autoplay</span> <span class="attr">loop</span>=<span class="string">&quot;true&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>属性<ul><li>controls 控制面板</li><li>autoplay 自动播放</li><li>loop='true’循环播放</li></ul></li></ul></li><li><p>video：视频</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">src</span>=<span class="string">&quot;&quot;</span> <span class="attr">poster</span>=<span class="string">&quot;imgs/aa/jpg&quot;</span> <span class="attr">controls</span>&gt;</span><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>属性：<ul><li>poster：指定视频还没有完全下载完毕或用户还没有点击播放前显示的封面。默认显示当前视频文件的第一帧画面，poster 也可以自己指定。</li><li>controls 控制面板</li><li>width</li><li>height</li></ul></li></ul></li><li><p>source 标签：因为浏览器对视频格式支持程度不一样，为了能够兼容不同的浏览器，可以通过 source 来制定视频源。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&#x27;aa.flv&#x27;</span> <span class="attr">type</span>=<span class="string">&#x27;video/flv&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&#x27;aa.mp4&#x27;</span> <span class="attr">type</span>=<span class="string">&#x27;video/mp4&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>表单</p><ul><li><p>表单类型</p><ul><li>email:能够验证当前输入的邮箱地址是否合法</li><li>url:验证 URL</li><li>number:只能输入数字，其他输入不了，而且自带上下增大减小箭头，max 属性可以设置最大值，min 可以设置最小值，value 为默认值</li><li>search:输入框后面会给提供一个小叉号，可以删除输入的内容，更加人性化</li><li>range:可以提供给一个范围，其中可设置 min 和 max 以及 value，其中 value 属性可以设置为默认值。</li><li>color:颜色拾取器</li><li>time:时分秒</li><li>data:日期选择年月日</li><li>datatime:时间和日期（目前只有 Safari 支持）</li><li>datatime-local：日期时间控件</li><li>week:周控件</li><li>month:月控件</li></ul></li><li><p>表单属性：</p><ul><li>placeholder:提示信息</li><li>autofocus:自动获取焦点</li><li>autocomplete='on’或者 autocomplete='off’使用这个属性需要有两个前提：<ul><li>表单必须提交过</li><li>必须有 name 属性</li></ul></li><li>required:要求输入框不能为空，必须有值才能提交</li><li>pattern=&quot;&quot;里面写入想要的正则模式</li><li>multiple:可以选择多个文件或多个邮箱</li><li>form=&quot; form 表单的 ID&quot;</li></ul></li><li><p>表单事件：</p><ul><li>oninput:每当 input 里面输入的内容发生改变的时候都会触发这个事件</li><li>oninvalid:当验证不通过时触发该事件</li></ul></li><li><p>进度条、度量器</p><ul><li><p>progress 标签：用来表示任务的进度（IE、Safari 不支持），max 用来表示任务的进度，value 表示已完成多少</p></li><li><p>meter 属性：用来显示剩余容量或剩余库存（IE、Safari 不支持）</p><ul><li>high/low：规定被视作高/低的范围</li><li>max/min：规定最大/小值</li><li>value：规定当前度量值</li></ul><p>设置规则：min &lt; low &lt; high &lt; max</p></li></ul></li></ul></li><li><p>DOM 查询操作</p><ul><li>document.querySelector()</li><li>document.querySelectorAll()</li></ul></li><li><p>Web 存储：</p><ul><li>localStorage:没有时间限制的数据存储</li><li>sessionStorage:针对一个 session 的数据存储</li></ul></li><li><p>其他</p><ul><li><p>拖放：拖放是一种常见的特性，即抓取对象以后拖到另一个位置。设置元素可拖放：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">draggable</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>画布（canvas ）： canvas 元素使用 JavaScript 在网页上绘制图像。画布是一个矩形区域，可以控制其每一像素。canvas 拥有多种绘制路径、矩形、圆形、字符以及添加图像的方法。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;canvas <span class="attribute">id</span>=<span class="string">&quot;myCanvas&quot;</span> <span class="attribute">width</span>=<span class="string">&quot;200&quot;</span> <span class="attribute">height</span>=<span class="string">&quot;100&quot;</span>&gt;&lt;/canvas&gt;</span><br></pre></td></tr></table></figure></li><li><p>SVG：SVG 指可伸缩矢量图形，用于定义用于网络的基于矢量的图形，使用 XML 格式定义图形，图像在放大或改变尺寸的情况下其图形质量不会有损失，它是万维网联盟的标准</p></li><li><p>地理定位：Geolocation（地理定位）用于定位用户的位置。</p></li></ul></li><li><p>（1）新增语义化标签：nav、header、footer、aside、section、article （2）音频、视频标签：audio、video （3）数据存储：localStorage、sessionStorage （4）canvas（画布）、Geolocation（地理定位）、websocket（通信协议） （5）input 标签新增属性：placeholder、autocomplete、autofocus、required （6）history API：go、forward、back、pushstate</p></li></ul><h3 id="src-和-href-的区别">src 和 href 的区别</h3><blockquote><p>src 和 href 都是用来引入外部资源的</p></blockquote><ul><li>src 表示对资源的引用，它指向的内容会嵌套到标签所在的位置，src 会将其指向的资源下载并应用到文档中，如请求 js 脚本。当浏览器解析到该元素时，会停止对其他资源的下载和处理，直到该资源加载、编译、执行完毕，所以 js 脚本一般会放在页面底部。</li><li>href 表示超文本引用，它指向一些网络资源，建立其和当前元素或文档的链接关系。当浏览器识别到它指向的文件时，就会并行下载资源，不会停止对当前文档的处理，常用在 a、link 等标签上。</li></ul><h3 id="对-HTML-语义化的理解">对 HTML 语义化的理解</h3><blockquote><p>语义化就是根据内容的结构化选择适合的标签，通俗来讲就是用正确的标签做正确的事情，其优点如下：</p></blockquote><ul><li>对机器友好，带有语义的文字表现力更加丰富，更适合搜索引擎的爬虫爬取有效信息，有利于 SEO，除此之外，语义类还支持读屏软件，可根据文章自动生成目录。</li><li>对开发者友好，使用语义类标签增强可读性，结构更加清晰，开发者能清晰地看出网页的结构，便于团队的开发和维护。</li><li>常见的语义化标签</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">header</span>&gt;</span><span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">头部</span><br><span class="line"><span class="tag">&lt;<span class="name">section</span>&gt;</span><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br><span class="line">区块</span><br><span class="line"><span class="tag">&lt;<span class="name">nav</span>&gt;</span><span class="tag">&lt;/<span class="name">nav</span>&gt;</span></span><br><span class="line">导航</span><br><span class="line"><span class="tag">&lt;<span class="name">main</span>&gt;</span><span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line">主要区域</span><br><span class="line"><span class="tag">&lt;<span class="name">article</span>&gt;</span><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line">主要内容</span><br><span class="line"><span class="tag">&lt;<span class="name">aside</span>&gt;</span><span class="tag">&lt;/<span class="name">aside</span>&gt;</span></span><br><span class="line">侧边栏</span><br><span class="line"><span class="tag">&lt;<span class="name">footer</span>&gt;</span><span class="tag">&lt;/<span class="name">footer</span>&gt;</span></span><br><span class="line">底部</span><br></pre></td></tr></table></figure><h3 id="DOCTYPE（文档类型）的作用">DOCTYPE（文档类型）的作用</h3><blockquote><p>DOCTYPE 是 HTML5 中一种标准通用标记语言的文档类型声明，它的目的是告诉浏览器以什么样的文档类型定义来解析文档，不同的渲染模式会影响浏览器对 CSS 甚至 JS 脚本的解析，它必须声明在 HTML 的第一行。</p></blockquote><blockquote><p>浏览器渲染页面的模式分为两种（可通过 document.compatMode 获取）</p></blockquote><ul><li>CSS1Compat:<strong>标准模式</strong>，默认模式，浏览器使用 W3C 的标准解析渲染页面，在标准模式下，浏览器以其支持的最高标准呈现页面。</li><li>BackCompat：**怪异模式，**浏览器使用 自己的怪异模式解析页面。在怪异模式中，页面以一种较为宽松的向后兼容的方式显示。</li></ul><h3 id="script-标签中的-defer-和-async">script 标签中的 defer 和 async</h3><blockquote><p>如果没有 defer 和 async 属性，浏览器会立即加载并执行相应的脚本，不会等待后续加载的文档元素，读取到就会开始加载和执行，这样就阻塞了后续文档的加载。</p></blockquote><p>​ <img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20230713083346457.png" alt="image-20230713083346457"></p><p>注：蓝色代表 js 脚本网络加载时间，红色代表 js 脚本执行时间，绿色代表 html 解析。</p><blockquote><p>defer 和 async 都是异步加载外部 js 文件的，他们都不会阻塞页面的解析，区别如下：</p></blockquote><ul><li>执行顺序:多个带有 async 属性的标签，不能保证加载顺序，多个带有 defer 属性的标签，按其在文档中出现的顺序进行加载和执行。</li><li>脚本是否并行执行：<ul><li>async 属性：表示后续文档的加载和执行与 js 脚本的加载和执行是并行进行的，即异步执行。</li><li>defer 属性：表示后续文档和 js 脚本加载（不执行）是并行进行的，即异步执行，js 脚本需要等到文档所有元素加载完毕才能执行，DOMContentLoaded 事件触发执行之前。</li></ul></li></ul><h3 id="Web-Worker">Web Worker</h3><blockquote><p>Web Worker 是在 Web 浏览器中运行后台线程的机制，它允许在主线程之外执行长时间运行的计算和处理复杂任务，以避免阻塞用户界面的情况。Web Worker 能够并行执行任务，独立于主线程。下面是 Web Work 的一些特点：</p></blockquote><ul><li>独立于主线程：Web Worker 在后台运行，不会阻塞主进程的操作，这意味着可以在 Web Worker 中进行密集型或耗时的任务，而不会影响用户界面的响应性能。</li><li>无法访问 DOM：Web Worker 在独立线程中执行，因此无法直接访问或操作页面的 DOM 元素。这样可以确保线程不会与主线程发生冲突或竞争条件。</li><li>通过消息传递进行通信：主线程和 Web Worker 之间的通信是通过消息传递来实现的。主线程和 Web Worker 可以互相发送信息，并通过事件处理程序接收和处理收到的信息。</li><li>适用于耗时任务：Web Worker 特别适合于执行那些需要大量计算或涉及大量数据处理的任务，如：图像处理、大数据集操作、复杂算法等。</li></ul><p>使用 Web Worker 的基本流程：</p><ol><li><p>在主线程中创建一个新的 Web Worker 实例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> worker = <span class="keyword">new</span> <span class="title class_">Worker</span>(<span class="string">&quot;worker.js&quot;</span>);</span><br></pre></td></tr></table></figure></li><li><p>在 Web Worker 脚本文件（worker.js）中编写后台任务的代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//worker.js</span></span><br><span class="line"><span class="comment">//接收主线程消息的事件处理程序</span></span><br><span class="line">self.<span class="property">onmessage</span> = <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> data = event.<span class="property">data</span>;</span><br><span class="line">  <span class="comment">//执行后台任务</span></span><br><span class="line">  <span class="comment">//处理data数据</span></span><br><span class="line">  <span class="comment">//发送结果给主线程</span></span><br><span class="line">  self.<span class="title function_">postMessage</span>(result);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>通过 postMessage()方法将消息发送到 Web Worker，并通过 onmessage 事件处理程序接收来的 Web Worker 的消息。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//主线程</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//发送消息给Web Worker</span></span><br><span class="line">worker.<span class="title function_">postMessage</span>(data);</span><br><span class="line"></span><br><span class="line"><span class="comment">//接收Web Worker的消息</span></span><br><span class="line">worker.<span class="property">onmessage</span> = <span class="keyword">function</span> (<span class="params">event</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> result = event.<span class="property">data</span>;</span><br><span class="line">  <span class="comment">//处理Web Worker返回的结果</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结束Web Worker的运行</span></span><br><span class="line">worker.<span class="title function_">terminate</span>();</span><br></pre></td></tr></table></figure><p>总结：Web Worker 提供了一种在 Web 浏览器中执行后台任务的方法，可以提高用户界面的响应性能，特别适用于执行耗时任务。然而，由于 Web Worker 无法直接访问 dom，因此在使用 Web Worker 时需要注意并发加载和处理数据的方式，以及主线程之间的消息传递。</p></li></ol><h3 id="行内元素有哪些？块级元素有哪些？空元素有哪些？">行内元素有哪些？块级元素有哪些？空元素有哪些？</h3><ul><li>行内元素：a b span img input select strong</li><li>块级元素：div ul ol dl dt dd h1 h2 h3 h4 h5 h6 p</li><li>空元素，即没有内容的元素，空元素是在开始标签中关闭的，也就是空元素没有闭合标签：<ul><li>常见的有：<code>&lt;br&gt;</code>、<code>&lt;hr&gt;</code>、<code>&lt;img&gt;</code>、<code>&lt;input&gt;</code>、<code>&lt;link&gt;</code>、<code>&lt;meta&gt;</code>；</li><li>鲜见的有：<code>&lt;area&gt;</code>、<code>&lt;base&gt;</code>、<code>&lt;col&gt;</code>、<code>&lt;colgroup&gt;</code>、<code>&lt;command&gt;</code>、<code>&lt;embed&gt;</code>、<code>&lt;keygen&gt;</code>、<code>&lt;param&gt;</code>、<code>&lt;source&gt;</code>、<code>&lt;track&gt;</code>、<code>&lt;wbr&gt;</code>。</li></ul></li></ul><h3 id="title-和-h1-的区别、b-和-strong-的区别、i-和-em-的区别">title 和 h1 的区别、b 和 strong 的区别、i 和 em 的区别</h3><ul><li>title 没有明确意义只表示是个标题，h1 表示层次明确的标题，对抓取页面信息有很大的影响.</li><li>strong 有语义，是祈祷加重语气的效果，而 b 标签没有，b 标签只是一个简单的加粗标签，b 标签之间的字符都设置为粗体，strong 标签加强字符的语气都是通过粗体来实现的，而搜索引擎更侧重 strong 标签。</li><li>i 内容展示斜体，em 表示强调是一个文本。</li></ul><h3 id="iframe-标签">iframe 标签</h3><blockquote><p>在 HTML 中，<iframe></iframe>标签用于在页面中嵌入另一个 HTML 文档或外部网页。通过使用该标签，可以在当前页面显示其他网页或加载外部资源。</p></blockquote><ul><li>优点：<ul><li>用来加载速度较慢的内容（如广告）</li><li>可以使脚本并行下载</li><li>可以实现跨子域通信</li></ul></li><li>缺点：<ul><li>会阻塞主页面的 onload 事件</li><li>无法被一些搜索引擎识别</li><li>会产生很多页面，不容易管理</li></ul></li></ul><h3 id="head-标签有什么作用，其中什么标签必不可少？">head 标签有什么作用，其中什么标签必不可少？</h3><blockquote><p>head 标签用于定义文档的头部，它是所有头部元素的容器，用于定义页面的相关数据和外部资源，描述了文档的各种属性和信息，包括文档的标题、在 web 中的位置以及其他文档的关系，不会直接在浏览器中展示给用户。</p></blockquote><p>下面标签可用在 head 部分：<base>,<link>,<meta>,<script>,<style>,<title></p><h3 id="渐进增强和优雅降级之间的区别">渐进增强和优雅降级之间的区别</h3><ul><li>渐进增强：主要针对低版本的浏览器进行页面的重构，保证基本功能的情况下，在针对高级浏览器进行效果、交互等方面的改进和追加功能，已达到更好的用户体验。</li><li>优雅降级：一开始就构建完整的功能，然后再针对低版本的浏览器进行兼容。</li><li>两者的区别：<ul><li>优雅降级是从复杂的现状开始的，并试图减少用户体验的供给，而渐进增强是从一个非常基础的、能够其作用的版本开始的，并在此基础上不断扩充，以适应未来环境的需要。</li><li>降级意味着往回看，渐进增强意味着往前看，同时保证其根基处于安全地带。</li></ul></li><li>“优雅降级”观点认为应该针对那些最高级、最完善的浏览器来设计网站，而那些被认为“过时”或有功能缺失的浏览器下的测试工作应该安排在开发周期的最后阶段，并把测试对象限定为主流浏览器的前一个版本。在这种设计范例下，旧版浏览器被认为仅能提供“简陋却无妨”的浏览体验，可以做一些小的调整来适应某个特定的浏览器。但是由于他们并非我们所关注的焦点，因此除了修复较大的错误之外，其他的差异将被直接忽略。</li><li>“渐进增强”观点则认为应关注内容本身，内容是建立网站的诱因，有的网站展示它，有的则是为了收集它，有的追求，有的操作，还有的网站甚至包含以上的种种，但是相同点是它们全部涉及到内容。这使得“渐进增强”成为了一种更为合理的设计范例。</li></ul><h3 id="说一下-HTML5-drag-API">说一下 HTML5 drag API</h3><ul><li>dragstart：事件主体是被拖放元素，在开始拖放被拖放元素时触发。</li><li>darg：事件主体是被拖放元素，在正在拖放被拖放元素时触发。</li><li>dragenter：事件主体是目标元素，在被拖放元素进入某元素时触发。</li><li>dragover：事件主体是目标元素，在被拖放在某元素内移动时触发。</li><li>dragleave：事件主体是目标元素，在被拖放元素移出目标元素是触发。</li><li>drop：事件主体是目标元素，在目标元素完全接受被拖放元素时触发。</li><li>dragend：事件主体是被拖放元素，在整个拖放操作结束时触发。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>手写代码面试笔记（更新中...）</title>
      <link href="/posts/7f3c58c6.html"/>
      <url>/posts/7f3c58c6.html</url>
      
        <content type="html"><![CDATA[<h3 id="数组和对象的扁平化">数组和对象的扁平化</h3><blockquote><p>数组和对象的扁平化是将多层嵌套的数组或对象转换为只有一层的形式。</p></blockquote><ol><li><p>使用递归和 concat 方法实现扁平化数组：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">flattenArrayRecursive</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="comment">//[1,2,3,[4,5,6]]=&gt;[1,2,3,4,5,6]</span></span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Array</span>.<span class="title function_">isArray</span>(arr)</span><br><span class="line">    ? arr.<span class="title function_">reduce</span>(<span class="function">(<span class="params">acc, curr</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> acc.<span class="title function_">concat</span>(<span class="title function_">flattenArrayRecursive</span>(curr));</span><br><span class="line">      &#125;, [])</span><br><span class="line">    : [arr];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用扩展运算符和递归方法扁平化数组：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">flattenArraySpread</span>(<span class="params">arr</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> arr.<span class="title function_">some</span>(<span class="title class_">Array</span>.<span class="property">isArray</span>)</span><br><span class="line">    ? <span class="title function_">flattenArraySpread</span>([].<span class="title function_">concat</span>(...arr))</span><br><span class="line">    : arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用 reduce 方法和 Object.assign 扁平化对象：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function  flattenObjectReduce(obj,prefix=&#x27;&#x27;)&#123;</span><br><span class="line">    return Object.keys(obj).reduce((acc,key)=&gt;&#123;</span><br><span class="line">        var pre=prefix.length?prefix+&#x27;.&#x27;:&#x27;&#x27;;</span><br><span class="line">        if(typeof obj[key]===&#x27;object&#x27;&amp;&amp;obj[key]!==null)&#123;</span><br><span class="line">            Object.assign(acc,flattenObjectReduce(obj[key],pre+key))</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            acc[pre+key]=obj[key]</span><br><span class="line">        &#125;</span><br><span class="line">        return acc;</span><br><span class="line">    &#125;,&#123;&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="Object-create">Object.create</h3><blockquote><p>Object.create()是 js 中的一个方法，用于创建一个新对象，新对象的原型（prototype）是指定的对象。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">create</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">F</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">  F.<span class="property"><span class="keyword">prototype</span></span> = obj;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">F</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="instanceof-方法">instanceof 方法</h3><blockquote><p>instanceof 用于判断构造函数的 prototype 属性是否出现在对象的原型链中的任何位置。</p></blockquote><ul><li>实现步骤：<ul><li>获取类型的原型</li><li>获得对象的原型</li><li>一直循环判断对象的原型是否等于类型的原型，直到对象原型为 null，因为原型链最终为 null</li></ul></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">myInstanceof</span>(<span class="params">obj, fn</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> proto = <span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(obj); <span class="comment">//获取对象的原型</span></span><br><span class="line">  <span class="keyword">let</span> prototype = fn.<span class="property"><span class="keyword">prototype</span></span>; <span class="comment">//获取构造函数的prototype对象</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!proto) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (proto == prototype) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    proto = <span class="title class_">Object</span>.<span class="title function_">getPrototypeof</span>(prop);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="手写-new-操作符">手写 new 操作符</h3><ul><li><p>首先创建一个空对象</p></li><li><p>设置原型，将对象的原型设置为函数的 prototype 对象</p></li><li><p>让函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）</p></li><li><p>判断函数的返回值类型，如果是值类型，返回创建的对象，如果是引用类型，就返回这个引用类型的对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">objectFactory</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> newObject = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">let</span> constructor = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">shift</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>);</span><br><span class="line">  <span class="keyword">let</span> result = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 判断参数是否是一个函数</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> constructor !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">error</span>(<span class="string">&quot;type error&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 新建一个空对象，对象的原型为构造函数的 prototype 对象</span></span><br><span class="line">  newObject = <span class="title class_">Object</span>.<span class="title function_">create</span>(constructor.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line">  <span class="comment">// 将 this 指向新建对象，并执行函数</span></span><br><span class="line">  result = constructor.<span class="title function_">apply</span>(newObject, <span class="variable language_">arguments</span>);</span><br><span class="line">  <span class="comment">// 判断返回对象</span></span><br><span class="line">  <span class="keyword">let</span> flag =</span><br><span class="line">    result &amp;&amp; (<span class="keyword">typeof</span> result === <span class="string">&quot;object&quot;</span> || <span class="keyword">typeof</span> result === <span class="string">&quot;function&quot;</span>);</span><br><span class="line">  <span class="comment">// 判断返回结果</span></span><br><span class="line">  <span class="keyword">return</span> flag ? result : newObject;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用方法</span></span><br><span class="line"><span class="title function_">objectFactory</span>(构造函数, 初始化参数);</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 手写代码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法笔记（更新中...）</title>
      <link href="/posts/7f3c58c5.html"/>
      <url>/posts/7f3c58c5.html</url>
      
        <content type="html"><![CDATA[<h3 id="剑指-Offer-09-用两个栈实现队列"><a href="https://leetcode.cn/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof/">剑指 Offer 09. 用两个栈实现队列</a></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="title class_">CQueue</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">inStatck</span> = [];</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">outStack</span> = [];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">value</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">void</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">CQueue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">appendTail</span> = <span class="keyword">function</span> (<span class="params">value</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">inStatck</span>.<span class="title function_">push</span>(value);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">CQueue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">deleteHead</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">outStack</span>.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="property">inStatck</span>.<span class="property">length</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">reserveStack</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">outStack</span>.<span class="title function_">pop</span>();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">CQueue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">reserveStack</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="variable language_">this</span>.<span class="property">inStatck</span>.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">outStack</span>.<span class="title function_">push</span>(<span class="variable language_">this</span>.<span class="property">inStatck</span>.<span class="title function_">pop</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your CQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * var obj = new CQueue()</span></span><br><span class="line"><span class="comment"> * obj.appendTail(value)</span></span><br><span class="line"><span class="comment"> * var param_2 = obj.deleteHead()</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h3 id="剑指-Offer-04-二维数组中的查找"><a href="https://leetcode.cn/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof/">剑指 Offer 04. 二维数组中的查找</a></h3><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20230715203004735.png" alt="image-20230715203004735"></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[][]</span>&#125; <span class="variable">matrix</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">target</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">boolean</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> findNumberIn2DArray = <span class="keyword">function</span> (<span class="params">matrix, target</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!matrix.<span class="property">length</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">let</span> i = matrix.<span class="property">length</span> - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> j = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &lt; matrix[<span class="number">0</span>].<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (matrix[i][j] &lt; target) &#123;</span><br><span class="line">      j++;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (matrix[i][j] &gt; target) &#123;</span><br><span class="line">      i--;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="剑指-Offer-32-II-从上到下打印二叉树-II"><a href="https://leetcode.cn/problems/cong-shang-dao-xia-da-yin-er-cha-shu-ii-lcof/">剑指 Offer 32 - II. 从上到下打印二叉树 II</a></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> levelOrder = <span class="keyword">function</span> (<span class="params">root</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> queue = [];</span><br><span class="line">  <span class="keyword">let</span> res = [];</span><br><span class="line">  <span class="keyword">if</span> (!root) &#123;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">  queue.<span class="title function_">push</span>(root);</span><br><span class="line">  <span class="keyword">if</span> (queue.<span class="property">length</span> !== <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> len = queue.<span class="property">length</span>;</span><br><span class="line">    res.<span class="title function_">push</span>([]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">      <span class="keyword">let</span> node = queue.<span class="title function_">shift</span>();</span><br><span class="line">      res[res.<span class="property">length</span> - <span class="number">1</span>].<span class="title function_">push</span>(node.<span class="property">val</span>);</span><br><span class="line">      <span class="keyword">if</span> (node.<span class="property">left</span>) &#123;</span><br><span class="line">        queue.<span class="title function_">push</span>(node.<span class="property">left</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (node.<span class="property">right</span>) &#123;</span><br><span class="line">        queue.<span class="title function_">push</span>(node.<span class="property">right</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="剑指-Offer-45-把数组排成最小的数"><a href="https://leetcode.cn/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof/">剑指 Offer 45. 把数组排成最小的数</a></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">string</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> minNumber = <span class="keyword">function</span> (<span class="params">nums</span>) &#123;</span><br><span class="line">  nums = nums.<span class="title function_">sort</span>(<span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;&quot;</span> + a + b - (<span class="string">&quot;&quot;</span> + b + a);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> nums.<span class="title function_">join</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="剑指-Offer-10-II-青蛙跳台阶问题"><a href="https://leetcode.cn/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/">剑指 Offer 10- II. 青蛙跳台阶问题</a></h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number</span>&#125; <span class="variable">n</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> numWays = <span class="keyword">function</span> (<span class="params">n</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (n == <span class="number">0</span> || n == <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> f1 = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> f2 = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> f3 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    f3 = (f1 + f2) % <span class="number">1000000007</span>;</span><br><span class="line">    f1 = f2;</span><br><span class="line">    f2 = f3;</span><br><span class="line">    <span class="keyword">if</span> (i === n) &#123;</span><br><span class="line">      <span class="keyword">return</span> f3;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="剑指-Offer-63-股票的最大利润"><a href="https://leetcode.cn/problems/gu-piao-de-zui-da-li-run-lcof/">剑指 Offer 63. 股票的最大利润</a></h3><ul><li>暴力法</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">prices</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> maxProfit = <span class="keyword">function</span> (<span class="params">prices</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> max = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; prices.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; prices.<span class="property">length</span>; j++) &#123;</span><br><span class="line">      <span class="keyword">let</span> profit = prices[j] - prices[i];</span><br><span class="line">      <span class="keyword">if</span> (profit &gt; max) &#123;</span><br><span class="line">        max = profit;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> max;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>在价格最低点买入，之后比较之前获得的最大利润加上今天的是否比之前的大，当前价格是否比最小价格小。也就是最低点买入后，只需考虑之后的每一天到底要不要买出。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">prices</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> maxProfit = <span class="keyword">function</span> (<span class="params">prices</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> max = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> minPrice = <span class="title class_">Number</span>.<span class="property">MAX_VALUE</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> price <span class="keyword">of</span> prices) &#123;</span><br><span class="line">    max = <span class="title class_">Math</span>.<span class="title function_">max</span>(max, price - minPrice);</span><br><span class="line">    minPrice = <span class="title class_">Math</span>.<span class="title function_">min</span>(price, minPrice);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> max;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="剑指-Offer-42-连续子数组的最大和"><a href="https://leetcode.cn/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof/">剑指 Offer 42. 连续子数组的最大和</a></h3><p><img src="C:%5CUsers%5CAdministrator%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20230726214338657.png" alt="image-20230726214338657"></p><blockquote><p>比较（左侧最大和）当前值与（左侧最大和）的大小，哪个大取哪个值。用 max 记录之前最大和，1、1 和-2+1 比较，取 1，max 记为 1；2、1±3 和-3 比较，取 1±3，max 记为-2,；3、4 与-2+4 比较，取 4，max&lt;4 ,max 记为 4…</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;<span class="type">number[]</span>&#125; <span class="variable">nums</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;<span class="type">number</span>&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> maxSubArray = <span class="keyword">function</span> (<span class="params">nums</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> leftMax = nums[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">let</span> max = nums[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; nums.<span class="property">length</span>; i++) &#123;</span><br><span class="line">    leftMax = <span class="title class_">Math</span>.<span class="title function_">max</span>(nums[i], leftMax + nums[i]);</span><br><span class="line">    max = leftMax &gt; max ? leftMax : max;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> max;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 后端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS面试笔记（更新中...）</title>
      <link href="/posts/7f3c58c2.html"/>
      <url>/posts/7f3c58c2.html</url>
      
        <content type="html"><![CDATA[<hr><h1>JS</h1><hr><h3 id="JS-有哪些数据类型，它们的区别？">JS 有哪些数据类型，它们的区别？</h3><ul><li>JS 共有八种数据类型，分别是 Undefined、String、Symbol、Object、Null、Number、Boolean、BigInt</li><li>Symbol 和 BigInt 是 es6 新增的数据类型：<ul><li>Symbol 代表创建后独一无二且不可变的数据类型，它主要是为了解决可能出现的全局变量冲突的问题。</li><li>BigInt 是一种数字类型的数据，它可以表示任意精度格式的整数，使用 BigInt 可以安全地存储和操作大整数，即使这个数字已经超出了 Number 能够表示的安全整数范围。</li></ul></li><li>这些数据可以分为原始数据类型和引用数据类型：<ul><li>栈：原始数据类型（Undefined、Null、Boolean、Number、String）</li><li>堆：引用数据类型（对象、数组、函数）</li></ul></li><li>两种类型的区别在于存储的位置不同：<ul><li>原始数据类型存储在栈（stack）中的简单数据段，占据空间小，大小固定，属于被频繁使用数据，所以放在栈中存储。</li><li>引用数据类型存储在堆(heap)中的对象，占据空间大，大小不固定。如果存储在栈中，将会影响程序的性能，引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。</li></ul></li><li>堆和栈的概念存在于数据结构和操作系统内存中，在数据结构中：<ul><li>栈中的数据的存取方式为先进后出</li><li>堆是一个优先队列，是按优先级来进行排序的，优先级可以按照大小来规定</li></ul></li><li>在操作系统中，内存被分为栈区和堆区：<ul><li>栈区内存有编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。</li><li>堆区内存一般由开发者分配释放，若开发者不释放，程序结束时可能由垃圾回收机制回收。</li></ul></li></ul><h3 id="判断数组的方式有哪些？">判断数组的方式有哪些？</h3><ol><li><p>通过 Object.prototype.toString.call()</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>.<span class="title function_">call</span>(obj).<span class="title function_">slice</span>(<span class="number">8</span>, -<span class="number">1</span>) === <span class="string">&quot;Array&quot;</span>;</span><br></pre></td></tr></table></figure></li><li><p>通过原型链做判断</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj.<span class="property">__proto__</span> = <span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>通过 ES6 的 Array.isArray()做判断</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="title function_">isArray</span>(obj);</span><br></pre></td></tr></table></figure></li><li><p>通过 instanceof 做判断</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj <span class="keyword">instanceof</span> <span class="built_in">Array</span></span><br></pre></td></tr></table></figure></li><li><p>通过 Array.prototype.isPrototypeOf</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Array</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">isPrototypeOf</span>(obj);</span><br></pre></td></tr></table></figure></li></ol><h3 id="null-和-undefined-的区别">null 和 undefined 的区别</h3><ul><li>首先 Undefined 和 null 都是基本数据类型，这两个基本数据类型分别都只有一个值，就是 undefined 和 null</li><li>null 表示一个被明确赋值为空值的值。它通常被用来表示变量或者属性的空值。</li><li>undefined 表示一个变量或者属性尚未定义或没有赋值，当声明一个变量但是没有给它赋值时，该变量被默认为 undefined，或者，如果一个对象中不存在某个属性，访问该属性时也会得到 undefined。</li><li>null 的使用场景：<ul><li>表示变量或属性的空值。</li><li>明确指示某个值为无效或不存在</li><li>通常由程序员赋值</li><li>可以用来重置变量，将其显式地设置为空。</li></ul></li><li>undefined 的使用场景：<ul><li>变量被声明但未被赋值。</li><li>对象访问属性时，该属性不存在。</li><li>函数没有明确返回值时，默认返回 undefined。</li></ul></li></ul><h3 id="数据类型检测的方式有哪些？">数据类型检测的方式有哪些？</h3><ol><li><p>typeof</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="number">2</span>); <span class="comment">//number</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="literal">true</span>); <span class="comment">//boolean</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="string">&quot;str&quot;</span>); <span class="comment">//string</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> []); <span class="comment">//object</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;); <span class="comment">//function</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> &#123;&#125;); <span class="comment">//object</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="literal">undefined</span>); <span class="comment">//undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> <span class="literal">null</span>); <span class="comment">//object</span></span><br></pre></td></tr></table></figure><ul><li>其中数组、对象、null 都会被判断为 object，其他判断都正确。</li></ul></li><li><p>instanceof</p><blockquote><p>instanceof 可以正确判断对象的类型，其内部运行机制是判断在其原型链中能否找到该类型的原型。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="number">2</span> <span class="keyword">instanceof</span> <span class="title class_">Number</span>); <span class="comment">//false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">true</span> <span class="keyword">instanceof</span> <span class="title class_">Boolean</span>); <span class="comment">//false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;str&quot;</span> <span class="keyword">instanceof</span> <span class="title class_">String</span>); <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>([] <span class="keyword">instanceof</span> <span class="title class_">Array</span>); <span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;&#125; <span class="keyword">instanceof</span> <span class="title class_">Function</span>); <span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(&#123;&#125; <span class="keyword">instanceof</span> <span class="title class_">Object</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><ul><li>可以看到，instanceof 只能正确判断引用数据类型，而不能判断基本数据类型（没有原型链），instanceof 运算符可以测试一个对象在其原型链中是否存在一个构造函数的 prototype 属性。</li></ul></li><li><p>constructor</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>((<span class="number">2</span>).<span class="property">constructor</span> === <span class="title class_">Number</span>); <span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">true</span>.<span class="property">constructor</span> === <span class="title class_">Boolean</span>); <span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;str&quot;</span>.<span class="property">constructor</span> === <span class="title class_">String</span>); <span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>([].<span class="property">constructor</span> === <span class="title class_">Array</span>); <span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;.<span class="property">constructor</span> === <span class="title class_">Function</span>); <span class="comment">//true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(&#123;&#125;.<span class="property">constructor</span> === <span class="title class_">Object</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure><ul><li><p>constructor 有两个作用，一是判断数据类型，二是对象实例通过 constructor 对象访问它的构造函数。注意，如果创建一个对象来改变它的原型，constructor 就不能用来判断数据类型了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Fn</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="title class_">Fn</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">Array</span>();</span><br><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> <span class="title class_">Fn</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(f.<span class="property">constructor</span> === <span class="title class_">Fn</span>); <span class="comment">//false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(f.<span class="property">constructor</span> === <span class="title class_">Array</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>Object.prototype.toString.call()</p><blockquote><p>Object.prototype.toString.call()使用 Object 对象的原型方法 toString 来判断数据类型。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">call</span>(<span class="number">2</span>)); <span class="comment">//[object Number]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">call</span>(<span class="literal">true</span>)); <span class="comment">//[object Boolean]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">call</span>(<span class="string">&quot;str&quot;</span>)); <span class="comment">//[object String]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">call</span>([])); <span class="comment">//[object Array]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">call</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;&#125;)); <span class="comment">//[object Function]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">call</span>(&#123;&#125;)); <span class="comment">//[object Object]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">call</span>(<span class="literal">undefined</span>)); <span class="comment">//[object Undefined]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a.<span class="title function_">call</span>(<span class="literal">null</span>)); <span class="comment">//[object Null]</span></span><br></pre></td></tr></table></figure><ul><li><p>同样是检测对象 obj 调用 toString 方法，obj.toString()的结果和 Object.prototype.toString.call(obj)的结果不一样，这是为什么？</p><p>这是因为 toString 是 Object 的原型方法，而 Array、function 等<strong>类型作为 Object 的实例，都重写了 toString 方法</strong>。不同的对象类型调用 toString 方法时，根据原型链的知识，调用的是对应的重写之后的 toString 方法（function 类型返回内容为函数体的字符串，Array 类型返回元素组成的字符串…），而不会去调用 Object 上原型 toString 方法（返回对象的具体类型），所以采用 obj.toString()不能得到其对象类型，只能将 obj 转换为字符串类型；因此，在想要得到对象的具体类型时，应该调用 Object 原型上的 toString 方法。</p></li></ul></li></ol><h3 id="typeof-null-的结果是什么？为什么？">typeof null 的结果是什么？为什么？</h3><ul><li><p>typeof null 的结果是 Object</p></li><li><p>在 js 最初的实现中，它使用 32 位的数据来存储变量的值，其中 3 位用于表示变量的类型信息。在这个类型信息中，对象类型被表示为二进制的 000，而 null 被认为是一个空指针对象，它的二进制表示正好是全部为 0。</p></li><li><pre><code class="language-js">000: object   - 当前存储的数据指向一个对象。  1: int      - 当前存储的数据是一个 31 位的有符号整数。010: double   - 当前存储的数据指向一个双精度的浮点数。100: string   - 当前存储的数据指向一个字符串。110: boolean  - 当前存储的数据是布尔值。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 当 js 在判断一个值类型时，会查看该值的类型信息，由于 <span class="literal">null</span> 的类型信息全部为 <span class="number">0</span>，与对象类型一致，因此 <span class="keyword">typeof</span> <span class="literal">null</span> 返回的是 Object</span><br><span class="line"></span><br><span class="line"><span class="meta">### 为什么 0.1+0.2！==0.3，如何让其相等</span></span><br><span class="line"></span><br><span class="line">```js</span><br><span class="line"><span class="keyword">let</span> n1 = <span class="number">0.1</span>,</span><br><span class="line">  n2 = <span class="number">0.2</span>;</span><br><span class="line">console.log(n1 + n2); <span class="comment">// 0.30000000000000004</span></span><br></pre></td></tr></table></figure></code></pre></li><li><p>要想得到 0.3，可以进行 bao’liu’lang’wei’xiao’shu</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(n1 + n2).<span class="title function_">toFixed</span>(<span class="number">2</span>);</span><br></pre></td></tr></table></figure><ul><li>计算机是通过二进制的方式存储数据的，所以计算机计算 0.1+0.2 的时候，实际上是计算两个数的二进制的和。0.1 的二进制是 0.00011001100110011001100…(1100 循环)，0.2 的二进制是 0.00110011001100…（1100 循环），这两个数的都是无限循环的数。</li><li>一般我们认为数字包括小数和整数，但是 js 中只有一种数字类型：Number，它的实现遵循 IEEE 745 标准，使用 64 位固定长度来表示，也就是标准的 double 双精度浮点数。在二进制科学表示法中，双精度浮点数的小数部分最多只能保留 52 位，再加上前面的 1，其实就是保留 53 位有效数字，剩余的需要舍去，遵从“0 舍 1 入”的原则。</li></ul><h3 id="typeof-NaN-的结果是什么？">typeof NaN 的结果是什么？</h3><ul><li><p>typeof NaN 的结果是 number</p></li><li><p>NaN 指“不是一个数字”，NaN 是一个“警戒线”，用于指出数字类型中的错误情况，即“执行数学运算没有成功，这是失败后返回的结果”</p></li><li><p>NaN 是一个特殊值，它和本身不相等，是唯一一个非自反的值，而 NaN!==NaN 为 true</p></li><li><p>在 JavaScript 中，NaN 代表非数字（Not-a-Number）。当涉及到 NaN 时，有一个特殊的规则：NaN 与任何值（包括 NaN 本身）进行比较时，结果都是 false。</p><p>这包括相等运算符（==和===），因此 NaN 与 NaN 进行比较会得到 false（NaN !== NaN）。这是因为 NaN 表示一个特殊的数值状态，它被认为是不可比较的、不等于任何其他值的。</p><p>这种设计是基于 JavaScript 中的 IEEE 754 浮点数标准，其中 NaN 是一种特殊的数值。它用于表示一些不确定或无效的运算结果，例如 0 除以 0 或负数的平方根。</p></li></ul><h3 id="Number-isNaN-和-isNaN-的区别？">Number.isNaN 和 isNaN 的区别？</h3><ul><li>函数 isNaN 接收参数后，会尝试将这个参数转换为数值，任何不能被转换为数值的值都会返回 true，因此非数字值传入也会返回 true，会影响 NaN 的判断。</li><li>函数 Number.isNaN 会首先判断传入参数是否为数字，如果是数字就继续判断是否为 NaN，不会进行数据类型的转换，这种方法更准确。</li></ul><h3 id="其他值到字符串的转换规则">其他值到字符串的转换规则</h3><ul><li>Null 和 Undefined 类型,null 转换为’null’,undefined 转换为&quot;undefined&quot;</li><li>Boolean 类型，true 转换为“true”,false 转换为&quot;false&quot;</li><li>Number 类型的值直接转换，不过那些极小和极大数会使用指数形式。</li><li>Symbol 类型的值直接转换，但是只允许显示强制类型转换，使用隐式强制类型转换会产生错误。</li><li>对于普通对象来说，除非自定义 toString()方法，否则会调用 toString()(Object.prototype.toString())来返回内部属性值，如&quot;[Object Object]&quot;，如果对象有自己的 toString()方法，字符串化时会调用该方法并使用其返回值。</li></ul><p><a href="http://Object.is">Object.is</a>()与操作符&quot;==“、”===&quot;的区别？</p><ul><li>使用双等号进行相等判断时，如果两边类型不一致，则会进行强制类型转化后再进行比较。</li><li>使用三等号进行相等判断时，如果两边的类型不一致，不会做强制类型转换，直接返回 false</li><li>使用 <a href="http://Object.is">Object.is</a>()来进行相等判断时，一般情况下和三等号的判断相同，他会处理一些特殊情况，比如：-0 和 0 不相等，两个 NaN 是相等的。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开端</title>
      <link href="/posts/7f3c58c1.html"/>
      <url>/posts/7f3c58c1.html</url>
      
        <content type="html"><![CDATA[<p>  个人网站搭建中…</p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
